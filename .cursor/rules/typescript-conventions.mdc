---
description: TypeScript and JavaScript code conventions for Dogs Parks application
globs: *.ts,*.tsx,*.js,*.jsx
alwaysApply: false
---

# TypeScript & JavaScript Code Conventions

This rule outlines the established coding conventions for TypeScript and JavaScript files in the Dogs Parks application.

## üìù Variable Naming

### **Clear and Descriptive Names**

```tsx
// ‚úÖ Good: Clear variable names
const userProfile = await fetchUser(userId);
const filteredParks = parks.filter((park) => park.isActive);
const sortedDogs = dogs.sort((dogA, dogB) =>
  dogA.name.localeCompare(dogB.name)
);

// ‚úÖ Good: Clear names in array functions
const dogNames = dogs.map((dog) => dog.name);
const activeFriends = friends.filter((friend) => friend.status === 'active');
const totalReviews = reviews.reduce(
  (total, review) => total + review.rating,
  0
);

// ‚ùå Bad: Unclear or abbreviated names
const u = await fetchUser(userId);
const fp = parks.filter((p) => p.isActive);
const sd = dogs.sort((a, b) => a.name.localeCompare(b.name));
```

### **Array Function Parameters**

```tsx
// ‚úÖ Good: Descriptive parameter names
const parkImages = parks.map((park) => park.primaryImage);
const userDogs = users.flatMap((user) => user.dogs);
const hasActiveDogs = dogs.some((dog) => dog.isActive);

// ‚ùå Bad: Generic parameter names
const parkImages = parks.map((x) => x.primaryImage);
const userDogs = users.flatMap((item) => item.dogs);
const hasActiveDogs = dogs.some((el) => el.isActive);
```

## üì§ Export Conventions

### **Exports at End of File**

```tsx
// ‚úÖ Good: All exports at the end
const fetchUser = async (userId: string) => {
  // function implementation
};

const createUser = async (userData: CreateUserParams) => {
  // function implementation
};

const updateUser = async (userId: string, updates: UpdateUserParams) => {
  // function implementation
};

// All exports at the end
export { fetchUser, createUser, updateUser };

export type { CreateUserParams, UpdateUserParams };
```

```tsx
// ‚ùå Bad: Exports scattered throughout file
export const fetchUser = async (userId: string) => {
  // function implementation
};

const createUser = async (userData: CreateUserParams) => {
  // function implementation
};

export const updateUser = async (userId: string, updates: UpdateUserParams) => {
  // function implementation
};

export { createUser }; // Export in middle of file
```

## üîß Control Flow

### **Always Use Curly Braces**

```tsx
// ‚úÖ Good: Always use curly braces for if statements
if (user.isActive) {
  return user.profile;
}

if (dogs.length > 0) {
  setHasDogs(true);
}

if (error) {
  console.error('Error occurred:', error);
  return null;
}

// ‚úÖ Good: Multi-line conditions with braces
if (user.isActive && user.hasPermission && user.dogs.length > 0) {
  showUserProfile();
}

// ‚ùå Bad: Single-line if statements without braces
if (user.isActive) return user.profile;
if (dogs.length > 0) setHasDogs(true);
if (error) console.error('Error occurred:', error);
```

### **Consistent Bracing for All Control Structures**

```tsx
// ‚úÖ Good: Consistent bracing
for (const dog of dogs) {
  processDog(dog);
}

while (isLoading) {
  await delay(100);
}

try {
  const result = await apiCall();
  return result;
} catch (error) {
  handleError(error);
}

// ‚ùå Bad: Inconsistent bracing
for (const dog of dogs) processDog(dog);
while (isLoading) await delay(100);
```

## üìä Function Parameters

### **Object Parameters for Multiple Props**

```tsx
// ‚úÖ Good: Object parameter for multiple props/params
const createPark = async (params: CreateParkParams) => {
  const { name, location, size, facilities } = params;
  // function implementation
};

const updateUserProfile = async (data: UpdateProfileParams) => {
  const { userId, name, email, preferences } = data;
  // function implementation
};

// ‚úÖ Good: Single parameter can be direct
const fetchUser = async (userId: string) => {
  // function implementation
};

const deleteItem = async (itemId: string) => {
  // function implementation
};

// ‚ùå Bad: Multiple individual parameters
const createPark = async (
  name: string,
  location: Location,
  size: number,
  facilities: string[]
) => {
  // function implementation
};

const updateUserProfile = async (
  userId: string,
  name: string,
  email: string,
  preferences: UserPreferences
) => {
  // function implementation
};
```

## üèóÔ∏è Type Definitions

### **Interface Naming Conventions**

#### **For .ts Files (Services, Utils, etc.)**

```tsx
// ‚úÖ Good: [FunctionName]Params for .ts files
interface CreateUserParams {
  name: string;
  email: string;
  password: string;
}

interface UpdateParkParams {
  parkId: string;
  name?: string;
  size?: number;
  facilities?: string[];
}

interface FetchNotificationsParams {
  userId: string;
  limit: number;
  cursor?: string;
}

const createUser = async (params: CreateUserParams) => {
  // implementation
};

const updatePark = async (params: UpdateParkParams) => {
  // implementation
};

const fetchNotifications = async (params: FetchNotificationsParams) => {
  // implementation
};
```

#### **For .tsx Files (Components)**

```tsx
// ‚úÖ Good: [ComponentName]Props for .tsx files
interface UserProfileProps {
  user: User;
  isEditable: boolean;
  onUpdate: (user: User) => void;
}

interface DogCardProps {
  dog: Dog;
  showOwner?: boolean;
  onClick?: (dogId: string) => void;
}

interface ModalProps {
  isOpen: boolean;
  title: string;
  children: ReactNode;
  onClose: () => void;
}

const UserProfile: React.FC<UserProfileProps> = (props) => {
  const { user, isEditable, onUpdate } = props;
  // component implementation
};

const DogCard: React.FC<DogCardProps> = (props) => {
  const { dog, showOwner = false, onClick } = props;
  // component implementation
};
```

### **Use Interfaces Over Types**

```tsx
// ‚úÖ Good: Use interfaces for object shapes
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: string;
}

interface CreateDogParams {
  name: string;
  breed: string;
  birthday?: string;
  owner: string;
}

// ‚úÖ Good: Types for unions, primitives, and computed types
type Status = 'pending' | 'approved' | 'rejected';
type DogId = string;
type PartialUser = Partial<User>;

// ‚ùå Bad: Using type for object shapes that could be interfaces
type User = {
  id: string;
  name: string;
  email: string;
  createdAt: string;
};
```

## üìã Complete Examples

### **Service Function Example (.ts file)**

```tsx
interface FetchUserDogsParams {
  userId: string;
  includeInactive?: boolean;
  limit?: number;
}

interface CreateDogParams {
  name: string;
  breed: string;
  birthday?: string;
  owner: string;
}

const fetchUserDogs = async (params: FetchUserDogsParams) => {
  const { userId, includeInactive = false, limit = 50 } = params;

  try {
    let query = supabase.from('dogs').select('*').eq('owner', userId);

    if (!includeInactive) {
      query = query.is('deleted_at', null);
    }

    if (limit) {
      query = query.limit(limit);
    }

    const { data: dogs, error } = await query;

    if (error) {
      throw error;
    }

    return dogs;
  } catch (error) {
    throwError(error);
  }
};

const createDog = async (params: CreateDogParams) => {
  const { name, breed, birthday, owner } = params;

  try {
    const { data: dog, error } = await supabase
      .from('dogs')
      .insert([{ name, breed, birthday, owner }])
      .select('id')
      .single();

    if (error) {
      throw error;
    }

    return dog.id;
  } catch (error) {
    throwError(error);
  }
};

export { fetchUserDogs, createDog };

export type { FetchUserDogsParams, CreateDogParams };
```

### **Component Example (.tsx file)**

```tsx
interface DogListProps {
  dogs: Dog[];
  isLoading: boolean;
  onDogSelect: (dogId: string) => void;
  showOwnerInfo?: boolean;
}

const DogList: React.FC<DogListProps> = (props) => {
  const { dogs, isLoading, onDogSelect, showOwnerInfo = false } = props;

  if (isLoading) {
    return <Loader />;
  }

  if (dogs.length === 0) {
    return <EmptyState message="No dogs found" />;
  }

  const activeDogs = dogs.filter((dog) => dog.isActive);

  return (
    <div className={styles.container}>
      {activeDogs.map((dog) => (
        <DogCard
          key={dog.id}
          dog={dog}
          showOwner={showOwnerInfo}
          onClick={() => onDogSelect(dog.id)}
        />
      ))}
    </div>
  );
};

export { DogList };
```

## üö´ Anti-Patterns to Avoid

```tsx
// ‚ùå Bad: Unclear variable names
const d = dogs.filter((x) => x.active);
const u = await fetchUser(id);

// ‚ùå Bad: Exports scattered throughout file
export const func1 = () => {};
const func2 = () => {};
export const func3 = () => {};

// ‚ùå Bad: Single-line if without braces
if (error) throw error;
if (user) return user.name;

// ‚ùå Bad: Multiple individual parameters instead of object
const createUser = async (
  name: string,
  email: string,
  age: number,
  city: string
) => {};

// ‚ùå Bad: Wrong interface naming
interface CreateUserData {} // Should be CreateUserParams for .ts
interface UserCardData {} // Should be UserCardProps for .tsx

// ‚ùå Bad: Using type for object shapes
type User = {
  id: string;
  name: string;
}; // Should be interface
```

## üìã Checklist for TypeScript/JavaScript Files

- [ ] Variable names are clear and descriptive
- [ ] Array function parameters have meaningful names
- [ ] All exports are at the end of the file
- [ ] All if statements use curly braces (no single-line)
- [ ] Functions with multiple parameters use object parameters
- [ ] Interfaces are used for object type definitions
- [ ] Interface naming follows convention: `[FunctionName]Params` for .ts, `[ComponentName]Props` for .tsx
- [ ] Types are used only for unions, primitives, and computed types
- [ ] Control structures consistently use braces
- [ ] Code follows consistent formatting and style
