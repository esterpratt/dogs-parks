# Park Data Translation Implementation Plan

## Overview

Implement multilingual support for parks database data (name, city, address) to complement the existing i18n system for hardcoded strings. The app currently supports English (en) and Hebrew (he) with ~400 parks in the database. The system will use a **hybrid approach** optimized for cost and performance.

## Current System Analysis

### Data Flow

1. **JSON File**: Parks data is fetched from `parks.json` in Supabase storage for map/list views
2. **Database Queries**: Individual park data is fetched from `parks` table for detailed views
3. **Translation**: Currently only park attributes (size, materials) are translated in frontend

### New Approach

**Hybrid Approach**:

- **Homepage/List Views**: JSON files per language for cost-effective bulk data loading
- **Individual Park Details**: Single database query with complete park data and translations
- **Single source of truth**: Database remains authoritative, JSON files updated when needed

**Rationale:**

- **Cost Optimization**: Avoid expensive bulk database queries (400+ parks Ã— 3 languages per homepage load)
- **Performance**: JSON files load faster than database queries for bulk data
- **Efficient Caching**: Complete park data with translations cached per language for individual parks
- **Usage Pattern Alignment**: Bulk views accessed frequently, individual parks accessed on-demand

### Key Files

- `src/services/parks.ts`: `fetchParksJSON()`, `fetchPark()`
- `src/components/map/MarkerList.tsx`: Uses JSON data for map markers
- `src/components/parks/ParksList.tsx`: Uses JSON data for park list
- `src/components/parks/ParkPopup.tsx`: Displays park name, city, address from JSON
- `src/loaders/parkLoader.ts`: Fetches individual park data
- `src/i18n/`: Current i18n implementation with en/he support

## Implementation Phases

## ðŸ”§ YOUR MANUAL TASKS

### Phase 1: Database Setup in Supabase

#### 1.1 Create Tables & Schema

- **Create `park_translations` table** with columns:
  - `id` (UUID, primary key)
  - `park_id` (UUID, foreign key to parks table)
  - `language` (text, 'en' | 'he')
  - `name` (text)
  - `city` (text)
  - `address` (text)
  - `created_at` (timestamp)
  - `updated_at` (timestamp)
- **Add unique constraint** on `(park_id, language)`
- **Create indexes** on `park_id` and `language` columns

#### 1.2 Database Functions & Policies

- **Create RLS policies** for `park_translations` table (read access for all users)
- **Create database function** `get_parks_with_translations(language text)` for generating language-specific JSON files

#### 1.3 Data Population & Translation

- **Run migration scripts** (provided by AI) to populate English translations
- **Translate Hebrew data** using generated template
- **Upload translated data** to database
- **Generate and upload JSON files** using provided scripts
- **Remove old `parks.json`** from Supabase storage

---

## ðŸ¤– AI ASSISTANCE JOBS

### Job 1: Database Migration Scripts

- **Create migration script** to extract current parks data (name, city, address) and populate `park_translations` table with English data
- **Create Hebrew JSON** based on the json file `parks-he-initial.json`, populate the file `exports/parks-he.json` with the correct translations:
  - Try and match the parks from both files.
  - Each park that is already translated in the file `exports/parks-he.json` - replace the translations with the ones from `parks-he-initial.json`.
  - Summarize the missing parks from `parks-he-initial.json`.
  - Summarize the missing parks from `exports/parks-he.json`

### Job 2: Type Definitions & Interfaces

- **Update `src/types/park.ts`**:
  - Add `ParkTranslation` interface
  - Add `TranslatedPark` interface for JSON file structure
  - Keep base `Park` interface for database queries

### Job 3: Backend Services & Query Optimization

- **Update `src/services/parks.ts`**:
  - Update `fetchParksJSON(language: AppLanguage)` to fetch language-specific JSON files
  - Create `fetchParkWithTranslation(parkId: string, language: AppLanguage)` function using JOIN query to combine park data with translations

- **Query Key Strategy**:
  - **JSON-based bulk data**: `['parks', language]` (for homepage/list views)
  - **Individual park data**: `['park', parkId, language]` (complete park data with translations)
  - **Cache retention**: Keep all language versions cached, never invalidate on language switch

- **Fallback strategy implementation**: If JSON file fails to load, fall back to database query

### Job 4: Custom Hooks

- **Update existing hooks**:
  - `useParksJSON(language)` - fetches language-specific JSON file
  - `useParkWithTranslation(parkId)` - fetches complete park data with translations in single query
- **Create new hooks**:
  - `useParksSearch(searchTerm)` - handles cross-language search across both JSON files

### Job 5: Component Updates - Bulk Views (JSON-based)

- **Update `src/components/map/MarkerList.tsx`**:
  - Use `useParksJSON(currentLanguage)` instead of generic parks query
  - Prefetch other languages JSON files
  - Handle language-specific JSON structure
- **Update `src/components/parks/ParksList.tsx`**:
  - Use `useParksJSON(currentLanguage)` for translated park data
  - Update search to use `useParksSearch()` for cross-language functionality
- **Update `src/components/parks/ParkPopup.tsx`**:
  - Display translated name, city, address from JSON data
  - Maintain prefetching for park details page

### Job 6: Component Updates - Individual Views (Database-based)

- **Update `src/loaders/parkLoader.ts`**:
  - Use single `fetchParkWithTranslation(parkId, language)` query
  - Optimize loading strategy with language-aware caching
- **Update individual park components**:
  - Use `useParkWithTranslation(parkId)` hook
  - Efficient caching strategy

### Job 7: Cross-language Search Implementation

- **Cross-language search implementation**:
  - **Approach**: Search across both language JSON files simultaneously (client-side)
  - **Implementation**: Update `searchParksFunc` in `ParksList.tsx` to search both English and Hebrew data
  - **User Experience**: Users can search in any language and find results
  - **Performance**: Still instant results with no database queries, just searches both JSON files

### Job 8: Language Switching & Cache Management

- **Language switch handling**:
  - **JSON-based views**: Fetch new language JSON file, cache both versions
  - **Individual park views**: Fetch complete park data for new language, keep all language versions cached (never invalidate on language switch), instant loading if language data already cached
  - **Optimized loading states** for language transitions

- **Fallback strategy implementation**:
  - **JSON file fallback**: If language-specific JSON fails, fall back to English JSON
  - **Translation fallback**: If Hebrew translation missing, fall back to English
  - **Database fallback**: If JSON files fail, fall back to database queries
  - **Handle gracefully** in UI components

- **Performance optimization**:
  - **Smart caching strategy**: Cache JSON files with long TTL (data rarely changes), cache complete park data per language with long TTL, never invalidate translations on language switch - keep for fast re-switching
  - **Preloading**: Preload opposite language JSON file in background

## New Database Functions

### `get_parks_with_translations(language text)`

```sql
-- Returns all parks with complete data including translations for given language
-- Falls back to English if translation not available
-- Used for JSON file generation
-- Optimized with proper joins and indexing
```

## Updated Data Flow

### 1. Homepage/Map Views (JSON-based - Cost Optimized)

1. Component calls `useParksJSON(currentLanguage)`
2. Hook fetches `parks-{language}.json` from Supabase storage
3. Data includes combined park info + translations
4. React Query caches JSON data with long TTL
5. Fast rendering with pre-translated data
6. **Background prefetch**: After initial load, prefetch the other language JSON file for cross-language search

### 2. Parks List View (JSON-based with Cross-language Search)

1. Uses `useParksJSON(currentLanguage)` for display data
2. Uses `useParksSearch(searchTerm)` for cross-language search functionality
3. Search across both English and Hebrew JSON files simultaneously
4. Results displayed in user's current language
5. No database queries needed for search functionality

### 3. Individual Park Pages (Database-based - Optimized Caching)

1. Component uses `useParkWithTranslation(parkId)`
2. Hook uses single query: `fetchParkWithTranslation(parkId, language)`
3. Returns complete park data with translations in one request
4. Language switching refetches complete data but keeps all languages cached
5. Simpler logic, atomic data loading

### 4. Language Switching

1. **Bulk views**: Fetch new language JSON file, keep both in cache
2. **Individual views**: Fetch complete park data for new language, keep all languages cached
3. **Cache Strategy**: Never invalidate translations on language switch - keep for fast re-switching
4. **Cost-effective**: Cached translations eliminate repeated queries
5. **Fast switching**: Instant if language data already cached

## Cost & Performance Analysis

### Cost Optimization

- **Homepage loads**: JSON file download (storage cost) vs 400+ database queries (compute cost)
- **Individual parks**: Small translation queries vs full park data refetch
- **Language switching**: Minimal database impact
- **Scalability**: Cost doesn't increase significantly with user growth

### Performance Benefits

- **Bulk views**: JSON files load faster than database queries
- **Individual views**: Single query with complete data + optimized caching
- **Search**: Client-side cross-language filtering (no database queries needed)
- **Language switching**: Efficient cache utilization

## Migration Strategy

### Phase 1: Database Setup & Data Migration

- Create tables and functions in Supabase
- Run migration script to populate English translations
- Add Hebrew translations using provided template
- Generate initial JSON files

### Phase 2: Backend Implementation

- Update services for hybrid approach
- Implement optimized query strategy
- Test with subset of parks

### Phase 3: Frontend Integration

- Update components for hybrid data sources
- Add language switching support
- Test across all park-related features

### Phase 4: Performance Optimization & Cleanup

- Optimize JSON file generation process
- Fine-tune caching strategies
- Performance testing and monitoring

## Files to Create/Modify

### New Files

- `src/hooks/useParksJSON.ts` - JSON file fetching with language support
- `src/hooks/useParkWithTranslation.ts` - Single query for complete park data with translations
- `src/hooks/useParksSearch.ts` - Cross-language search functionality
- `scripts/migrate-park-translations.js` - Migration script
- `scripts/generate-parks-json.js` - JSON file generation script
- `scripts/generate-hebrew-template.js` - Translation template generator

### Modified Files

- `src/types/park.ts` - Add translation interfaces, separate JSON structure from database structure
- `src/services/parks.ts` - Update for hybrid approach (JSON + database)
- `src/components/map/MarkerList.tsx` - Use language-specific JSON data
- `src/components/parks/ParksList.tsx` - Use JSON data with enhanced search
- `src/components/parks/ParkPopup.tsx` - Display translations from JSON
- `src/loaders/parkLoader.ts` - Use optimized database query strategy
- `src/hooks/api/keys.ts` - Update query keys for hybrid caching strategy

## Data Migration Scripts (I can help with these)

### 1. English Translation Population

```javascript
// Extract park data from parks.json file and populate park_translations table with English data
// Uses the provided parks.json file as data source (same as current database)
// Ensures all existing parks have English translations
```

### 2. Hebrew Translation Template Generator

```javascript
// Generate CSV/JSON template with all park data for Hebrew translation
// Includes park ID, current English name/city/address, and empty Hebrew fields
```

### 3. JSON File Generator

```javascript
// Generate parks-en.json and parks-he.json from database
// Returns complete park data with translations from single database query
// Uploads to Supabase storage
```

### 4. Data Validation Script

```javascript
// Verify data integrity after migration
// Check for missing translations and data consistency
// Validate JSON file structure
```

## Success Criteria

1. **Cost Optimization**: Minimal database queries for bulk data, efficient individual queries
2. **Performance**: Fast loading for both bulk views (JSON) and individual views (cached database)
3. **Hybrid Efficiency**: Best of both worlds - cost-effective bulk loading + real-time individual data
4. **Cross-language Search**: Users can search in any language and find results
5. **Fallback Handling**: Graceful handling of missing translations and failed requests
6. **Language Switching**: Efficient cache management with minimal cost impact
7. **Maintainable**: Easy to update JSON files and add new languages
8. **Scalable**: Cost remains reasonable as user base grows

---

## ðŸ”„ ONGOING MAINTENANCE (Your Tasks)

### When Park Data Changes

1. **Update database translations** in `park_translations` table
2. **Regenerate JSON files** using provided scripts:
   - Run `node scripts/generate-parks-json.js`
   - Upload new `parks-en.json` and `parks-he.json` to Supabase storage
3. **Validate data integrity** using provided validation script

### Adding New Languages

1. **Add new language entries** to `park_translations` table
2. **Generate new JSON file** (e.g., `parks-fr.json`) using scripts
3. **Update frontend** to support new language (AI can help with this)
